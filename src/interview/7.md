# 正在进行中

## React 组件之间怎么进行通信

在 React 中，组件之间可以通过多种方式进行通信。下面是一些常见的方法：

- Props 传递：通过将数据作为 props（属性）传递给子组件来实现通信。父组件可以将数据作为 props 传递给子组件，子组件可以通过 props 访问这些数据。这是 React 中最常见和最简单的通信方式之一。
- 上下文（Context）：上下文提供了一种在组件之间共享数据的方式，而不需要通过 props 一层层传递。可以使用 React 的 Context API 创建一个上下文，并通过在父组件中设置提供者（Provider），将数据传递给子组件。子组件可以通过在其组件层次结构中访问上下文来获取这些数据。
- 事件传递：父组件可以将回调函数作为 props 传递给子组件，并在需要时调用该回调函数来通知父组件发生了某些事件或状态的变化。这样可以实现子组件向父组件通信的目的。
- 全局状态管理：可以使用第三方状态管理库（如Redux、Mobx）来管理应用程序的全局状态。这些库提供了一种在组件之间共享状态的机制，使得组件可以读取和修改全局状态，从而实现通信和共享数据。
- 自定义事件系统：在某些情况下，可以使用自定义事件系统来实现组件之间的通信。可以创建一个事件中心（event emitter），组件可以订阅事件或触发事件，从而实现消息的传递和响应。

## Redux 使用过吗，谈谈你对它的理解

Redux 是一个用于 JavaScript 应用程序的状态管理库，常用于 React 应用程序中。它遵循一种被称为"Flux"架构的模式，通过集中管理应用程序的状态，使得状态的变化可预测且易于理解。

Redux 的核心概念包括：

1.  Store（存储）：它是应用程序状态的单一来源，包含了整个应用程序的状态树。在 Redux 中，通过创建一个 store 来存储应用程序的状态，并提供了一些方法来访问和修改这个状态。
2.  Action（动作）：表示对应用程序状态进行修改的意图。它是一个普通的 JavaScript 对象，包含一个描述性的 type 字段，以及可选的负载数据。当需要修改状态时，通过派发（dispatch）一个 action 来触发状态的变化。
3.  Reducer（规约器）：用于根据接收到的 action 来更新状态。Reducer是一个纯函数，接收当前状态和 action 作为参数，返回一个新的状态对象。它的作用是根据 action 的类型来确定如何更新状态，并返回新的状态对象。
4.  Middleware（中间件）：提供了一种扩展 Redux 功能的机制。中间件位于 action 被派发到达 reducer 之前，可以对 action 进行拦截、处理副作用、异步操作等。常见的中间件有 Redux Thunk、Redux Saga、Redux Promise 等。

Redux的工作流程通常是这样的：当用户执行某个操作时，应用程序会派发一个action来描述这个操作的意图，然后通过 reducer 来处理这个 action，生成新的状态。新的状态会被存储在 store 中，然后通知所有订阅了 store 的组件进行更新。

Redux的优点包括：

1.  单一数据源：整个应用程序的状态集中存储在一个 store 中，使得状态管理更加可控和可预测。
2.  可预测性：通过派发 action 和使用纯函数的 reducer 来修改状态，使得状态变化可追踪和可测试。
3.  方便的调试和时间旅行（Time Travel）：Redux 提供了强大的开发者工具，可以轻松地查看应用程序的状态变化历史，甚至可以回溯到之前的状态。
4.  生态系统丰富：Redux 已经成为 React 生态系统中最流行的状态管理库之一，有大量的相关插件和扩展可用。

但是，Redux 在小型应用或简单场景下使用可能会显得繁琐，因为它引入了许多额外的概念和模板代码。因此，在选择是否使用 Redux 时，需要权衡应用程序的规模和复杂性，以及是否真正需要管理全局状态。对于简单的组件间通信，使用 React 的 props 传递可能已经足够。

## 使用过 React 中的哪些 hooks，详细说说其中的三个

React中常用的hooks有useState、useEffect、useContext、useReducer等。其中：

1. useState：useState 是 React 内置的一个 hook，它使函数式组件能够保存和更新其自己的状态。它接收初始状态值作为参数，并且返回一个数组，包含当前状态和更新状态的方法。使用 useState 可以非常方便地在函数组件中管理组件状态。
2. useEffect：useEffect 是 React 提供的另一个重要 hook，它允许我们在组件渲染之后执行副作用操作（如数据获取，DOM 操作等）。useEffect 接收两个参数，第一个参数是一个函数，这个函数会在每次渲染时都会被执行；第二个参数是一个数组，它用于指定依赖项，如果依赖项发生改变，那么 useEffect 就会执行。
3. useContext：useContext 是 React 中的一个 Context API hook，它允许我们在组件树中传递数据而无需显式地通过 props 层层传递。useContext 接收一个 context 对象作为参数，并且返回该 context 对应的值。使用 useContext 可以轻松地在组件中访问全局数据状态，从而更加方便地进行跨组件通信。

## canvas 和 svg 有什么区别

Canvas 和 SVG 都是用于在浏览器中绘制图形的技术，但它们有着不同的工作原理和应用场景。

Canvas 是基于像素的绘图技术，它使用 JavaScript 在 HTML5 中动态创建画布，并通过绘制API将图形绘制到画布上。在 Canvas 中，所有绘制的元素都被转换成像素，并直接渲染到屏幕上。这使得 Canvas 非常适合绘制大量的动态图形和游戏等需要频繁重绘的场景。但相对来说，Canvas 对于复杂的图形处理（如：文本、变形、事件处理等）较为困难，因为 Canvas 只能操作图像的像素点，无法直接访问图像的结构和属性。

SVG 则是基于矢量的绘图技术，它使用 XML 语言描述二维图形，并通过浏览器解析并显示图像。SVG 图形是由一系列的矢量路径组合而成，其可以进行缩放、旋转、变形等变换操作，同时也支持事件绑定和 CSS 样式控制。由于 SVG 是基于矢量的，因此可以很好地处理高分辨率的图像，也比较适合静态的图形展示。

总的来说，Canvas 更适合实现动态效果，而 SVG 更适合处理静态图形和可缩放的图像。在实际应用中，我们可以根据具体需要灵活选择使用 Canvas 还是 SVG 技术。

## 谈谈你对 setTimeout, await/async, Promise 的理解

setTimeout、await/async 和 Promise 是 JavaScript 异步编程中常用的三种方式，它们的作用略有不同。

- setTimeout 是一个由浏览器提供的函数，用于在一定时间后执行指定的代码。它是一种基本的异步编程技术，可以用来实现简单的延迟执行或轮询操作。
- Promise 是一种表示异步操作结果的对象，它可以被认为是一个容器，保存了某个未来才会结束的事件（通常是一个异步操作）的结果。通过 Promise 对象可以获取异步操作的成功或失败结果，并基于该结果进行下一步的处理。
- await/async 是 ECMAScript 2017 中引入的新特性，它可以用来让异步代码像同步代码一样易于理解和编写。其中 await 关键字用于等待一个 Promise 对象的结果，而 async 函数则是一种定义异步函数的方式，它默认返回一个 Promise 对象。

尽管这三种技术都与 JavaScript 的异步编程相关，它们之间的主要区别是：setTimeout 是基于回调函数的方式来管理异步操作；Promise 是一种基于对象的异步编程方法，它可以更方便地进行异步操作的链式调用和错误处理；而 await/async 则是一种基于语言特性的方式，它使得异步代码看起来像同步代码，并且提高了异步代码的可读性和可维护性。

## 谈谈你对 React 虚拟 DOM 的理解

React 的虚拟 DOM（Virtual DOM）是React的一个关键概念，它是一个轻量级的、内存中的表示层级结构的 JavaScript 对象。虚拟 DOM 充当了 React 和实际 DOM 之间的中间层，用于高效地更新和渲染用户界面。

虚拟DOM的工作原理如下：

1.  初始渲染：当 React 组件被首次渲染时，它会创建一个虚拟 DOM 树，该树完全描述了组件的层次结构和内容。虚拟 DOM 树是纯粹的 JavaScript 对象，与实际 DOM 相比更轻量、更快速。
2.  更新阶段：当组件的状态或属性发生变化时，React会通过比较前后两个虚拟 DOM 树的差异，确定需要更新的部分。这个过程被称为"协调"（reconciliation）。
3.  差异计算：React 使用一种高效的算法来计算虚拟 DOM 树之间的差异。它会比较两个树的节点，并找出需要插入、删除或更新的节点。
4.  更新实际 DOM：在计算出差异后，React 将仅更新实际 DOM 中需要更改的部分，而不是重新渲染整个界面。这样可以避免不必要的性能开销。

通过使用虚拟 DOM，React 能够提供以下几个优点：

1.  高效的 DOM 更新：React 通过批处理和最小化 DOM 操作的方式，将实际 DOM 更新的次数减到最低。它通过比较虚拟 DOM 树的差异，仅更新必要的部分，从而提高了性能。
2.  跨平台兼容性：虚拟 DOM 使得 React 可以在不同平台上工作，包括 Web、移动端和服务器端。因为 React 只依赖于 JavaScript，它可以渲染出适应各种平台的用户界面。
3.  方便的开发者工具：虚拟 DOM 使得 React 可以轻松地提供开发者工具，用于可视化显示组件的层次结构、状态的变化，甚至可以进行时间旅行（time-travel）调试。
4.  更好的性能和用户体验：通过虚拟 DOM 的快速更新和渲染机制，React提供了更流畅的用户体验。它还可以减少对实际DOM的直接操作，降低了出错的可能性。

虚拟 DOM 是 React 的核心机制之一，它在 React 的性能、可维护性和开发体验上发挥着重要的作用。通过使用虚拟 DOM，React 能够更高效地处理大型应用程序的更新和渲染，并提供了一种声明式的方式来构建用户界面。

## React 的性能优化有哪些

在React中，有许多方法可以用于优化性能，以提高应用程序的响应性和用户体验。以下是一些常见的React性能优化技巧：

1.  使用合适的 shouldComponentUpdate 或 React.memo：通过在类组件中实现 shouldComponentUpdate 生命周期方法，或者在函数组件中使用 React.memo 高阶组件，可以控制组件是否进行重新渲染。这样可以避免不必要的渲染，提高性能。
2.  列表和集合的键（key）：在渲染列表或集合时，确保为每个子元素提供唯一的键。这样可以帮助 React 更准确地识别哪些元素需要进行更新、添加或删除，减少不必要的操作。
3.  懒加载和代码分割：通过使用 React.lazy 和 Suspense，可以将组件的加载延迟到需要使用它们时。这样可以减少初始加载时间，并提高页面的响应速度。另外，使用工具如 Webpack 的代码分割功能，可以将应用程序的代码拆分成更小的块，按需加载，减少初始加载的大小。
4.  使用 PureComponent 或 React.memo：使用 PureComponent 类代替 Component 类可以自动进行浅比较来确定是否需要重新渲染组件。React.memo 高阶组件也可以在函数组件中提供类似的性能优化。
5.  避免在渲染期间执行昂贵的操作：在渲染期间，尽量避免执行昂贵的操作，如网络请求、复杂计算等。这样可以保持渲染的快速和流畅。
6.  使用 React DevTools 进行性能分析：React DevTools 是 React 官方提供的开发者工具，可以用于检查组件的渲染时间、更新频率等。通过分析这些数据，可以识别潜在的性能问题，并进行优化。
7.  使用适当的组件拆分和组织：将大型组件拆分为更小的、可重用的子组件，可以提高代码的可维护性和可读性，并使React能够更细粒度地控制组件的渲染。
8.  使用 React Profiler 进行性能分析：React Profiler 是 React 16.5 及更高版本中提供的工具，可以用于检测和分析组件的渲染性能。通过识别性能瓶颈，可以有针对性地进行优化。

## TCP 三次握手，四次挥手

TCP（传输控制协议）是一种面向连接的协议，用于可靠地传输数据。它使用三次握手和四次挥手来建立和终止连接。下面是TCP三次握手和四次挥手的过程：

三次握手：

1. 第一步：客户端向服务器发送一个带有SYN（同步）标志的包，将初始序列号设定为随机数（ClientSeq）。
2. 第二步：服务器接收到SYN包后，向客户端发送一个带有 SYN/ACK 标志的包作为回应。该包中将确认序列号（Acknowledgement Number）设置为 ClientSeq + 1，并将自己的初始序列号（ServerSeq）设定为随机数。
3. 第三步：客户端接收到服务器发送的 SYN/ACK 包后，向服务器发送一个带有ACK标志的包作为确认。该包中将确认序列号设置为 ServerSeq + 1，表示客户端接收到了服务器的回应。

经过以上三个步骤，客户端和服务器完成了三次握手过程，建立了可靠的连接，双方可以开始传输数据。

四次挥手：

1. 第一步：当客户端想要关闭连接时，发送一个带有 FIN（结束）标志的包给服务器，并且停止发送数据。客户端进入 FIN_WAIT_1 状态，等待服务器的确认。
2. 第二步：服务器接收到客户端发送的FIN包后，发送一个带有 ACK 标志的包作为确认，并进入 CLOSE_WAIT 状态。此时服务器仍然可以向客户端发送数据。
3. 第三步：当服务器不再有数据要发送时，发送一个带有 FIN 标志的包给客户端。服务器进入 LAST_ACK 状态，等待客户端的确认。
4. 第四步：客户端接收到服务器发送的FIN包后，发送一个带有 ACK 标志的包作为确认，并进入 TIME_WAIT 状态。在这个状态下，客户端等待一段时间，以确保服务器收到了确认。随后，客户端关闭连接，服务器也关闭连接，并进入 CLOSED 状态。

通过以上四个步骤，客户端和服务器完成了四次挥手过程，双方成功终止了连接。在 TIME_WAIT 状态结束之后，客户端和服务器都可以重新开始建立新的连接。

## 做过小程序吗，原生还是 uni-app

## 对后端有了解吗，Node, MongoDB, Redis 这些了解吗

## 大屏项目做过吗，AntV 用过吗

## 3D 项目做过吗
